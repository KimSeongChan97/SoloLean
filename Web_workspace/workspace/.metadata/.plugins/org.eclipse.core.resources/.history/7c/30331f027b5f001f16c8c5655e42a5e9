<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>화살표 함수</title>
</head>
<body>

<script type="text/javascript">
	// 전통적인 함수 선언 방식
	function make1(){ // 구현
		// 'Have a nice day !!'를 콘솔에 출력
		console.log('Have a nice day !!');
		// 'Have a nice day !!'를 HTML 문서에 출력
		document.write('Have a nice day !!');
	}
	make1() // 호출 - 위에서 정의된 make1 함수를 실행
	document.write("<br>") // HTML에서 줄바꿈을 위해 <br> 태그를 추가

	// 매개변수 num을 받아 출력하는 전통적인 함수
	function make2(num){ // num이라는 매개변수를 받음
		// 매개변수 num의 값을 콘솔에 출력
		console.log(`num = ${num}`);
		// 매개변수 num의 값을 HTML 문서에 출력
		document.write(`num = ${num}`);
	}
	make2(100) // 호출 - make2 함수에 100을 인수로 전달하고 실행
	document.write("<br>") // HTML에서 줄바꿈을 위해 <br> 태그를 추가
	
	// 두 개의 매개변수 a, b를 받아 더한 값을 출력하는 함수
	function make3(a, b){ // 두 매개변수 a와 b를 받음
		// a와 b를 더한 결과를 콘솔에 출력
		console.log(`${a} + ${b} = ${a + b}`);
		// a와 b를 더한 결과를 HTML 문서에 출력
		document.write(`${a} + ${b} = ${a + b}`);
	}
	make3(25, 36) // 호출 - make3 함수에 25와 36을 전달하고 실행
	document.write("<br>") // HTML에서 줄바꿈을 위해 <br> 태그를 추가
	
	// 화살표 함수 - 기존 함수와 동일한 기능을 간결한 구문으로 구현
	const make11 = () => { // 화살표 함수는 () => { ... } 형태로 정의
		// 'Have a nice day !?'를 콘솔에 출력
		console.log('Have a nice day !?');
		// 'Have a nice day !?'를 HTML 문서에 출력
		document.write('Have a nice day !?');
	}
	make11() // 호출 - 위에서 정의된 make11 화살표 함수를 실행
	document.write("<br>") // HTML에서 줄바꿈을 위해 <br> 태그를 추가
	
	// 매개변수 num을 받아 출력하는 화살표 함수
	const make22 = (num) => { // 매개변수 num을 받는 화살표 함수
		// 매개변수 num의 값을 콘솔에 출력
		console.log(`num = ${num}`);
		// 매개변수 num의 값을 HTML 문서에 출력
		document.write(`num = ${num}`);
	}
	make22(100) // 호출 - make22 화살표 함수에 100을 전달하고 실행
	document.write("<br>") // HTML에서 줄바꿈을 위해 <br> 태그를 추가
	
	// 두 개의 매개변수 a와 b를 받아 더한 값을 출력하는 화살표 함수
	const make33 = (a, b) => { // 두 매개변수 a와 b를 받는 화살표 함수
		// a와 b를 더한 결과를 콘솔에 출력
		console.log(`${a} + ${b} = ${a + b}`);
		// a와 b를 더한 결과를 HTML 문서에 출력
		document.write(`${a} + ${b} = ${a + b}`);
	}
	make33(25, 36) // 호출 - make33 화살표 함수에 25와 36을 전달하고 실행
	
</script>

</body>
</html>

<!-- 
① 매개변수가 없을 경우
function(){} → () => { ... }

② 매개변수가 한 개인 경우, 소괄호를 생략 가능
function(x){} → x => { ... }

③ 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.
function(x, y){} → (x, y) => { ... } 

Java의 람다 표현식과 비교하여..

const에 대한 자세한 설명:
- const는 값이 고정된 상수를 선언할 때 사용됩니다. 한번 값을 할당하면 재할당이 불가능합니다.
- const는 블록 스코프를 따르며, 해당 블록 안에서만 유효합니다. let과 마찬가지로 const도 블록 스코프입니다.
- const는 선언과 동시에 반드시 초기화되어야 합니다. 선언만 하고 값을 나중에 할당할 수 없습니다.
- const로 선언한 변수에 객체나 배열을 할당하면, 그 객체의 속성이나 배열의 요소는 변경할 수 있지만, 변수 자체를 다른 값으로 변경할 수는 없습니다.
예:
const x = 10; // x는 상수로 값이 10으로 고정됨.
const arr = [1, 2, 3]; // 배열 arr의 요소는 변경할 수 있음. arr.push(4) 가능.
하지만 arr = [5, 6]와 같이 배열 자체를 재할당할 수는 없음.

전통적인 함수 선언 방식:
make1(), make2(num), make3(a, b) 함수들은 전통적인 함수 선언 방식으로, 각각 console.log()와 document.write()를 사용해 값을 출력합니다.
make2()와 make3() 함수는 매개변수를 사용하여 입력값을 처리합니다.

화살표 함수:
화살표 함수는 더 간결하게 함수를 정의할 수 있습니다. 예를 들어, const make11 = () => {}는 전통적인 함수 선언을 대체하며, 함수의 문법을 단순화합니다.
화살표 함수는 주로 콜백 함수나 짧은 함수를 작성할 때 유용합니다. 화살표 함수는 자신의 this를 가지지 않으며, 이를 상위 스코프의 this와 공유합니다.
const 키워드 설명:

const는 한 번 할당된 값을 변경할 수 없으므로, 상수 또는 변하지 않는 데이터를 저장할 때 사용됩니다.
선언 시 즉시 초기화가 필요하며, 블록 스코프를 따릅니다.
배열이나 객체를 const로 선언할 때, 그 내부의 값은 변경 가능하지만, 변수 자체는 재할당할 수 없습니다.
-->
