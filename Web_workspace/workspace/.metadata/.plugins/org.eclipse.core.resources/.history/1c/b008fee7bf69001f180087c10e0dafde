package guestbook.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import guestbook.bean.GuestbookDTO;

public class GuestbookDAO {
    private String driver = "oracle.jdbc.driver.OracleDriver";
    // 오라클 JDBC 드라이버의 클래스 이름을 문자열로 지정합니다.
    // 이 드라이버는 자바 프로그램이 오라클 데이터베이스와 상호작용할 수 있도록 해줍니다.
    private String url = "jdbc:oracle:thin:@localhost:1521:xe"; 
    // 오라클 데이터베이스에 연결하기 위한 URL입니다.
    // 이 예제에서는 로컬호스트에서 실행 중인 XE(Express Edition) 데이터베이스에 연결합니다.
    // 'thin' 드라이버는 오라클 서버에 직접 접속하는 네이티브 드라이버입니다.
    private String username = "C##JAVA";  // DB 사용자명
    // 데이터베이스에 접속하기 위한 사용자명을 지정합니다.
    // 이 사용자명은 오라클 데이터베이스에 설정된 계정명입니다.
    private String password = "1234";  // DB 비밀번호
    // 데이터베이스에 접속하기 위한 비밀번호를 지정합니다.
    // 해당 비밀번호는 username에 해당하는 사용자의 비밀번호입니다.
    
    private Connection conn; // 데이터베이스와의 연결을 나타내는 객체입니다.
    // Connection 객체는 SQL 쿼리를 실행할 때 데이터베이스와 연결을 유지합니다.
    private PreparedStatement pstmt; // SQL 문을 실행하기 위한 객체입니다.
    // PreparedStatement는 SQL 문을 미리 컴파일하여 성능을 높이고 SQL 인젝션 공격을 방지합니다.
    private ResultSet rs; // SQL 쿼리의 결과를 저장하기 위한 객체입니다.
    // ResultSet은 SELECT 쿼리의 결과를 저장하고, 그 결과를 한 행씩 읽어옵니다.
    
    private static GuestbookDAO guestbookDAO = new GuestbookDAO();
    // 싱글톤 패턴을 사용하여 GuestbookDAO 클래스의 유일한 인스턴스를 생성합니다.
    // 싱글톤 패턴은 클래스의 인스턴스가 오직 하나만 생성되도록 보장하며, 
    // 해당 인스턴스를 전역적으로 사용할 수 있게 합니다.
    
    // 싱글톤 패턴으로 GuestbookDAO 인스턴스 생성 및 반환
    public static GuestbookDAO getInstance() {
        // 이 메서드를 통해 GuestbookDAO의 유일한 인스턴스를 반환합니다.
        // 외부에서 이 메서드를 통해서만 GuestbookDAO 객체에 접근할 수 있습니다.
        return guestbookDAO;
    }

    public GuestbookDAO() {
        
        try {
            // 1. 드라이버 로딩
            // JDBC 드라이버를 메모리에 로드합니다. 이 작업은 데이터베이스와의 연결을 시작하기 전에 반드시 필요합니다.
            // 이때, 드라이버 클래스의 정적 초기화 블록에서 DriverManager에 드라이버가 등록됩니다.
            Class.forName(driver);
            // Class.forName() 메서드는 드라이버 클래스를 메모리에 로드하여 실행 준비를 완료합니다.
            // 이 과정에서 오라클 드라이버가 내부적으로 DriverManager에 등록됩니다.
        } catch (ClassNotFoundException e) {
            // 드라이버 클래스가 존재하지 않을 경우 발생하는 예외를 처리합니다.
            // 주로 드라이버 라이브러리가 클래스패스에 포함되지 않았을 때 발생합니다.
            e.printStackTrace();
            // e.printStackTrace()는 예외의 자세한 정보를 출력합니다. 이 정보를 통해 어디에서 오류가 발생했는지 파악할 수 있습니다.
        }
    }
    
    private Connection getConnection() throws SQLException {
        // 데이터베이스와의 연결을 설정하고, 그 연결을 나타내는 Connection 객체를 반환합니다.
        // DriverManager.getConnection() 메서드를 사용하여 데이터베이스에 접속합니다.
        // 이 메서드는 JDBC URL, 사용자명, 비밀번호를 인자로 받아 데이터베이스에 연결합니다.
        return DriverManager.getConnection(url, username, password);
        // 이 코드가 실행되면, JDBC 드라이버가 오라클 데이터베이스에 연결을 시도하고, 연결에 성공하면 Connection 객체가 반환됩니다.
    }

    public void guestbookWrite(GuestbookDTO guestbookDTO) {
        // guestbookWrite 메서드는 guestbookDTO 객체를 받아 이를 데이터베이스에 삽입하는 기능을 수행합니다.
        // 이 메서드는 사용자로부터 입력받은 방명록 데이터를 데이터베이스에 저장합니다.
        try {
            conn = getConnection(); 
            // getConnection() 메서드를 호출하여 데이터베이스 연결을 얻습니다.
            // 이 연결을 통해 SQL 문을 데이터베이스에 전달할 수 있습니다.
            
            String sql = """
                    insert into guestbook values(seq_guestbook.nextval, ?,?,?,?,?, sysdate)
                    """;
            // SQL INSERT 문을 정의합니다. 이 문장은 guestbook 테이블에 새 레코드를 삽입하며,
            // seq_guestbook.nextval을 통해 자동으로 증가하는 시퀀스 값을 사용합니다.
            // ?는 SQL 문에서 파라미터를 나타내며, 나중에 pstmt.setString()을 통해 값이 채워집니다.
            // 이 문장은 데이터베이스에서 다음과 같이 실행됩니다:
            // INSERT INTO guestbook VALUES (다음 시퀀스 값, 이름, 이메일, 홈페이지, 제목, 내용, 현재 시간);
            // SYSDATE는 현재 시스템의 날짜와 시간을 나타냅니다.

            pstmt = conn.prepareStatement(sql); 
            // PreparedStatement 객체를 생성합니다. 이 객체는 SQL 문을 실행하기 위해 사용됩니다.
            // conn.prepareStatement(sql)은 주어진 SQL 문을 미리 컴파일하여 PreparedStatement 객체로 반환합니다.
            // PreparedStatement는 SQL 문을 실행할 때마다 문장을 다시 컴파일할 필요가 없어 성능이 향상됩니다.

            // ? 에 데이터 대입
            // 각 ?에 해당하는 위치에 guestbookDTO 객체로부터 값을 가져와 대입합니다.
            pstmt.setString(1, guestbookDTO.getName()); // 첫 번째 ?에 이름 값을 대입합니다.
            // 첫 번째 파라미터에는 guestbookDTO 객체에서 가져온 사용자의 이름이 대입됩니다.
            pstmt.setString(2, guestbookDTO.getEmail()); // 두 번째 ?에 이메일 값을 대입합니다.
            // 두 번째 파라미터에는 guestbookDTO 객체에서 가져온 사용자의 이메일이 대입됩니다.
            pstmt.setString(3, guestbookDTO.getHomepage()); // 세 번째 ?에 홈페이지 값을 대입합니다.
            // 세 번째 파라미터에는 guestbookDTO 객체에서 가져온 사용자의 홈페이지 URL이 대입됩니다.
            pstmt.setString(4, guestbookDTO.getSubject()); // 네 번째 ?에 제목 값을 대입합니다.
            // 네 번째 파라미터에는 guestbookDTO 객체에서 가져온 방명록 제목이 대입됩니다.
            pstmt.setString(5, guestbookDTO.getContent()); // 다섯 번째 ?에 내용 값을 대입합니다.
            // 다섯 번째 파라미터에는 guestbookDTO 객체에서 가져온 방명록 내용이 대입됩니다.

            pstmt.executeUpdate(); 
            // SQL 문을 실행하여 데이터베이스에 변경 사항을 적용합니다. 
            // 이 메서드는 실행된 행의 수를 반환합니다. 하지만 여기서는 반환값을 사용하지 않습니다.
            // executeUpdate() 메서드는 INSERT, UPDATE, DELETE와 같은 데이터 변경 SQL 문을 실행할 때 사용됩니다.
            // 이 메서드는 실행된 행의 수를 반환하므로, 이를 통해 몇 개의 행이 변경되었는지 알 수 있습니다.
            
        } catch (SQLException e) {
            // SQL 실행 중 오류가 발생할 경우 예외를 처리합니다.
            // 예를 들어, 데이터베이스 연결 오류, SQL 문법 오류 등이 발생할 수 있습니다.
            e.printStackTrace();
            // 예외가 발생하면 해당 예외의 스택 추적 정보를 출력하여 오류 원인을 파악합니다.
        } finally {
            try {
                if (pstmt != null) pstmt.close();
                // PreparedStatement 객체를 닫아 자원을 해제합니다.
                // pstmt.close()는 PreparedStatement 객체가 사용한 리소스를 해제하고, 데이터베이스와의 연결을 종료합니다.
                if (conn != null) conn.close();
                // Connection 객체를 닫아 데이터베이스 연결을 종료합니다.
                // conn.close()는 데이터베이스와의 연결을 종료하여 불필요한 리소스 사용을 방지합니다.
            } catch (SQLException e) {
                // 자원 해제 중 예외가 발생할 경우 이를 처리합니다.
                // 예를 들어, 연결 종료 중에 발생하는 SQL 예외를 처리합니다.
                e.printStackTrace();
                // 예외가 발생하면 해당 예외의 스택 추적 정보를 출력하여 오류 원인을 파악합니다.
            }
        }
    }

    // 추가된 메서드: 방명록 리스트를 가져오는 메서드
    public List<GuestbookDTO> guestbookList() {
        List<GuestbookDTO> list = new ArrayList<>();
        // 방명록 데이터를 담을 리스트를 생성합니다.
        
        try {
            conn = getConnection();
            // 데이터베이스 연결을 얻습니다.
            
            String sql = "SELECT * FROM guestbook ORDER BY seq DESC";
            // 방명록 데이터를 가져오기 위한 SQL SELECT 문을 정의합니다.
            // 최근에 작성된 글이 먼저 출력되도록 ORDER BY 절을 사용하여 내림차순으로 정렬합니다.
            
            pstmt = conn.prepareStatement(sql);
            // SQL 문을 실행하기 위해 PreparedStatement 객체를 생성합니다.
            
            rs = pstmt.executeQuery();
            // SQL SELECT 문을 실행하고 그 결과를 ResultSet에 저장합니다.
            
            while (rs.next()) {
                // ResultSet의 다음 행으로 이동하면서 데이터가 있으면 계속 반복합니다.
                
                GuestbookDTO guestbookDTO = new GuestbookDTO();
                // ResultSet의 현재 행에서 데이터를 읽어와 GuestbookDTO 객체에 저장합니다.
                guestbookDTO.setSeq(rs.getInt("seq"));
                guestbookDTO.setName(rs.getString("name"));
                guestbookDTO.setEmail(rs.getString("email"));
                guestbookDTO.setHomepage(rs.getString("homepage"));
                guestbookDTO.setSubject(rs.getString("subject"));
                guestbookDTO.setContent(rs.getString("content"));
                guestbookDTO.setLogtime(rs.getDate("logtime"));
                
                list.add(guestbookDTO);
                // 리스트에 GuestbookDTO 객체를 추가합니다.
            }
            
        } catch (SQLException e) {
            // SQL 실행 중 오류가 발생할 경우 예외를 처리합니다.
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) rs.close();
                // ResultSet 객체를 닫아 자원을 해제합니다.
                if (pstmt != null) pstmt.close();
                // PreparedStatement 객체를 닫아 자원을 해제합니다.
                if (conn != null) conn.close();
                // Connection 객체를 닫아 데이터베이스 연결을 종료합니다.
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        
        return list;
        // 방명록 리스트를 반환합니다.
    }
}
