package com.control;

import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
//import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import member.control.CommandProcess;

//@WebServlet
public class ControlServlet extends HttpServlet {
    private static final long serialVersionUID = 1L; // 서블릿의 고유 ID로 직렬화를 위한 고유값입니다.
    private Map<String, Object> map = new HashMap<String, Object>();
    // URL과 처리 클래스 객체를 저장하기 위한 Map입니다.
    
    @Override
    public void init(ServletConfig config) throws ServletException {
        // 서블릿이 초기화될 때 호출되는 메소드입니다.
        // 'config.getInitParameter("propertyConfig")'를 통해 초기화 파라미터로 전달된 설정 파일 경로를 가져옵니다.
        String propertyConfig = config.getInitParameter("propertyConfig");
        System.out.println("propertyConfig = " + propertyConfig);
        // 결과 : propertyConfig = D:/Web/workspace/memberMVC/src/main/webapp/WEB-INF/command.properties
        // 위의 경로에서 command.properties 파일을 읽어서 사용합니다.

        // command.properties 파일의 내용을 읽어서 Map 에 보관해야 합니다.
        FileInputStream fin = null;  // 파일을 읽기 위한 스트림 객체입니다.
        Properties properties = new Properties();  // Properties 객체는 key-value 쌍으로 데이터를 저장합니다.

        try {
            fin = new FileInputStream(propertyConfig);  
            // FileInputStream을 사용하여 properties 파일을 엽니다.
            properties.load(fin);  
            // properties.load() 메소드를 통해 파일의 내용을 Properties 객체에 로드합니다.
            System.out.println("properties = " + properties);  
            // 파일 내용을 출력하여 제대로 로드되었는지 확인합니다.

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fin != null) fin.close();
                // 파일 입출력 자원을 사용한 후에는 반드시 close()하여 자원을 해제합니다.
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        System.out.println();

        // Properties 객체에 저장된 key-value 쌍을 순회하면서 각 key에 해당하는 클래스 정보를 로드합니다.
        Iterator<Object> it = properties.keySet().iterator();
        while (it.hasNext()) {
            String key = (String) it.next();  // 각 key (URL 패턴)를 가져옵니다.
            System.out.println("key = " + key);  

            String className = properties.getProperty(key);  // key에 해당하는 클래스 이름을 가져옵니다.
            System.out.println("className = " + className);  

            try {
                // 클래스 이름을 기반으로 클래스를 동적으로 로드하여 인스턴스를 생성합니다.
                Class<?> classType = Class.forName(className);
                Object ob = classType.getConstructor().newInstance();
                // 생성한 객체를 출력하여 확인합니다.
                System.out.println("ob = " + ob);

                // key에 해당하는 클래스를 map에 저장합니다.
                map.put(key, ob);

            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
            } catch (SecurityException e) {
                e.printStackTrace();
            }

            System.out.println();
        } // while
    }
    
    // GET 요청을 처리하는 메소드
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        execute(request, response);  
        // 실제 처리를 담당하는 execute 메소드를 호출하여 GET 요청을 처리합니다.
    }
    
    // POST 요청을 처리하는 메소드
    protected void doPost(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        execute(request, response);  
        // 실제 처리를 담당하는 execute 메소드를 호출하여 POST 요청을 처리합니다.
    }
    
    // GET과 POST 요청에 대해 공통으로 처리하는 메소드
    protected void execute(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        System.out.println();
        // 서블릿을 작성하면 반드시 web.xml 에 등록해야 한다.
        // 요청이 들어올 때마다 이 메소드가 호출되며, 요청을 처리합니다.
        
        if(request.getMethod().equals("POST")) request.setCharacterEncoding("UTF-8");
        // POST 방식일 경우 요청 파라미터의 인코딩을 UTF-8로 설정합니다.

        // http://localhost:8080/memberMVC/member/writeForm.jsp.do
        // 요청한 URL 에서 "/member/writeForm.jsp" 부분을 불러오기
        String category = request.getServletPath();  
        System.out.println("category = " + category);
        // 출력결과 : category = /member/writeForm.jsp.do
        // 클라이언트가 요청한 URL에서 서블릿 경로를 가져옵니다.

        // Map 을 이용하여 key에 해당하는 클래스를 꺼내옵니다.
        // 예: "/member/writeForm.jsp.do"에 해당하는 member.service.WriteFormService 클래스
        CommandProcess com = (CommandProcess) map.get(category);  
        // 요청에 대한 처리를 담당하는 클래스(커맨드)를 map에서 가져옵니다.

        String view = null;  // JSP 파일 경로를 저장할 변수
        try {
            // 해당 커맨드 클래스의 requestPro 메소드를 호출하여 JSP 파일 경로를 가져옵니다.
            view = com.requestPro(request, response);
        } catch (Throwable e) {
            e.printStackTrace();
        }

        // JSP 파일로 포워딩합니다.
        RequestDispatcher dispatcher = request.getRequestDispatcher(view);  
        // JSP 파일 경로를 지정하여 RequestDispatcher 객체를 생성합니다.
        dispatcher.forward(request, response);  
        // RequestDispatcher를 통해 JSP로 요청을 포워딩합니다.
    }
    
}
