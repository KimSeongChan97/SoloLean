package member.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import member.bean.MemberDTO;

public class MemberDAO {

    // 1. 싱글톤 인스턴스 생성 (static으로 유일한 인스턴스를 유지)
    // 싱글톤 패턴을 사용하여 애플리케이션 내에서 MemberDAO의 인스턴스를 하나만 유지하고 사용하기 위함입니다.
    private static MemberDAO memberDAO = new MemberDAO();

    // 2. DataSource 객체 선언
    // DataSource는 Connection Pool을 통해 DB 연결을 효율적으로 관리합니다.
    private DataSource ds;
    

    
    // 3. 싱글톤 인스턴스를 반환하는 메서드
    // getInstance() 메서드를 통해 MemberDAO 객체를 전역에서 하나만 사용할 수 있습니다.
    public static MemberDAO getInstance() {
        return memberDAO;
    }

    // 4. 생성자에서 InitialContext를 통해 DataSource 설정
    // JNDI(Java Naming and Directory Interface)를 통해 Connection Pool에 접근하여 DataSource를 설정합니다.
    public MemberDAO() {
        try {
            Context ctx = new InitialContext(); // JNDI 초기화
            ds = (DataSource) ctx.lookup("java:comp/env/jdbc/oracle"); // DataSource Lookup
        } catch (NamingException e) {
            e.printStackTrace(); // JNDI 조회 실패 시 예외 처리
        }
    }

    // 5. ID 중복 확인 메서드 (idExistId)
    // 사용자가 입력한 ID가 DB에 존재하는지 확인합니다.
    // 회원가입 시 중복된 ID를 방지하기 위해 사용되며, 반환값으로 ID가 존재하면 true, 없으면 false를 반환합니다.
    public boolean idExistId(String id) {
        boolean exist = false; // 중복 여부를 저장할 변수, 기본값은 false (중복되지 않음)

        // Oracle용 SQL 쿼리문 (회원 테이블에서 id 중복 확인)
        // 주어진 아이디가 'member' 테이블에 존재하는지 확인하는 SELECT 쿼리문입니다.
        String sql = "SELECT * FROM member WHERE id = ?";

        // try-with-resources 구문을 사용하여 Connection, PreparedStatement, ResultSet 자동 자원 해제
        try (Connection con = ds.getConnection();  // DataSource로부터 Connection을 가져옵니다.
             PreparedStatement pstmt = con.prepareStatement(sql)) {
            
            // SQL 쿼리에 id 값 바인딩
            // '?' 자리에 사용자가 입력한 id 값을 설정합니다.
            pstmt.setString(1, id);

            // SQL 실행 및 결과 처리
            // 쿼리를 실행하고 결과를 받아옵니다. ResultSet 객체를 통해 결과를 처리합니다.
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    exist = true; // 중복된 ID가 존재함
                }
            }
        } catch (SQLException e) {
            e.printStackTrace(); // SQL 실행 중 예외 발생 시 오류 출력
        }

        return exist; // true: 중복된 아이디가 있음, false: 사용 가능한 아이디
    }

    // 6. 회원 정보를 DB에 저장하는 메서드 (insertMember)
    // 회원가입 시 사용자가 입력한 데이터를 DB에 저장합니다.
    // MemberDTO 객체에 담긴 데이터를 이용해 DB에 새 회원을 삽입합니다.
    public void memberWrite(MemberDTO memberDTO) {
        // INSERT 쿼리로 'member' 테이블에 사용자의 정보를 삽입합니다.
        String sql = "INSERT INTO member (ID, PWD, NAME, GENDER, EMAIL1, EMAIL2, TEL1, TEL2, TEL3, ZIPCODE, ADDR1, ADDR2, LOGTIME) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, sysdate)";

        // try-with-resources 구문을 사용하여 자원을 자동 해제합니다.
        try (Connection con = ds.getConnection();  // DataSource로부터 Connection을 가져옵니다.
             PreparedStatement pstmt = con.prepareStatement(sql)) {
        	
            // 각 필드를 SQL 쿼리에 바인딩
            // '?'에 해당하는 값을 MemberDTO 객체에서 가져와 설정합니다.
            pstmt.setString(1, memberDTO.getId()); // 아이디 설정
            pstmt.setString(2, memberDTO.getPwd()); // 비밀번호 설정
            pstmt.setString(3, memberDTO.getName()); // 이름 설정
            pstmt.setString(4, memberDTO.getGender()); // 성별 설정
            pstmt.setString(5, memberDTO.getEmail1()); // 이메일 앞부분 설정
            pstmt.setString(6, memberDTO.getEmail2()); // 이메일 뒷부분 설정
            pstmt.setString(7, memberDTO.getTel1()); // 전화번호 앞자리 설정
            pstmt.setString(8, memberDTO.getTel2()); // 전화번호 중간자리 설정
            pstmt.setString(9, memberDTO.getTel3()); // 전화번호 뒷자리 설정
            pstmt.setString(10, memberDTO.getZipcode()); // 우편번호 설정
            pstmt.setString(11, memberDTO.getAddr1()); // 주소 설정
            pstmt.setString(12, memberDTO.getAddr2()); // 상세 주소 설정
             
            // SQL 실행
            pstmt.executeUpdate(); // INSERT 쿼리 실행하여 DB에 데이터를 저장합니다.

        } catch (SQLException e) {
            e.printStackTrace(); // 예외 발생 시 오류 메시지 출력
        }
    }
}
